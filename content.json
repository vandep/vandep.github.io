{"meta":{"title":"KekBin奇幻之旅","subtitle":null,"description":"IPFS/区块链/C#/技术博客/经验分享/windows/Android/全栈","author":"KekBin","url":"https://kekbin.com"},"pages":[{"title":"关于可可冰","date":"2018-06-07T05:28:49.937Z","updated":"2018-06-07T05:28:49.937Z","comments":true,"path":"about/index.html","permalink":"https://kekbin.com/about/index.html","excerpt":"","text":"一生太短，一瞬好长 联系我kekbin@163.com 个人主页IPFS主页 送你首歌血腥爱情故事 那时候的我"}],"posts":[{"title":"WebRTC--基础","slug":"webrtc-introduction-01","date":"2019-08-06T05:51:30.000Z","updated":"2019-08-06T06:20:25.022Z","comments":true,"path":"2019/08/06/webrtc-introduction-01/","link":"","permalink":"https://kekbin.com/2019/08/06/webrtc-introduction-01/","excerpt":"","text":"简介参考文献–官网 WebRtc通过一些简单的API来提供一种支持浏览器、移动应用之间的实时通信能力（Real-Time Communications），它具有以下特点： 免费的 开源的 12//代码地址git clone https://webrtc.googlesource.com/src 支持多平台：包括Chrome、FireFox、Opera、Android、IOS web应用端无需安装任何插件 Peer-to-Peer连接 支持视频流、音频流、字节流 所以常见用于音视频通话、会议、远程控制等架构参考文献–结构官网提供的结构如图所示： 包含内容： PeerConnection：所有的browser（或者说peer）通过建立PeerConnection进行通信 P2P连接：PeerConnection的连接相关包括Signalling、ICE、STUN、TURN SDP Manager：用Session desciption protocol描述会话 Capturer：callee peer通过AudioCapture/Video Capture抓取音视频流 Render：caller收到音视频流之后通过Audio/Video Render来渲染 Voice Engine：音频媒体链架构，从声卡到网络的管理 Video Engine：视频媒体链架构，从相机到网络或者从抓屏到网络的管理 VP8：一种视频编码，由于其低延时的设计，非常适合WebRtc Video Jitter Buffer：动态抖动缓冲视频。有助于隐藏抖动和包丢失对整体视频质量的影响 RTP Stack：实时流协议簇 下图解释了P2P之间实时流传递的工作原理，做为开发者需关注以下几个过程： Signalling用于Peer之间SDP交换 建立P2P连接 本地流的抓取及发送到远端 远端渲染流 其中P2P连接是WebRTC工作的关键，连接的过程后面我们将逐一介绍，下面先介绍一些概念和术语： SDP参考文献–协议RFC3264 参考文献–协议RFC2327 全称为Session Description protocol（会话描述协议），用于两个会话实体之间的媒体协商，并达成一致，属信令语言族，采用文本（字符）描述形式。rfc3264协议主要概述一个请求/响应模型（offer/answer），包括请求/响应的实体和不同阶段的操作行为，如初始协商过程和重协商过程，并简单介绍消息中各种参数的含义。具体各个参数的详细说明见rfc2327协议 什么是会话？一次电话会议、一次网络电话、一次视频传输，都是一次会话。也就是说，WebRTC中的Peer之间的连接属于一个会话。 那会话需要哪些描述呢？最基础的有多媒体数据格式和网络传输地址，当然还包括很多其他的配置信息。 为什么需要描述会话？因为参与会话的各个成员能力不对等。大家可能会想到使用所有人都支持的媒体格式，我们暂且不考虑这样的格式是否存在，我们思考另一个问题：如果参与本次会话的成员都可以支持更高质量的通话，那使用通用的、普通质量的格式，是不是合理？既然无法使用固定的配置，那对会话的描述就很有必要了。 最后，一次会话用什么配置，也不是由某一个人决定，必须所有人的意见达成一致，这样才能保证所有人都能参与会话。所以涉及到一个协商的过程了，会话发起者先提出一些建议（offer），其他人参与者再根据 offer 给出自己的选择（answer），最终意见达成一致后，才能开始会话。 ICE参考文献–协议RFC5245 参考文献–中文博客 WebRTC使用ICE框架来保证穿透。ICE全名叫交互式连接建立（Interactive Connectivity Establishment）,一种综合性的NAT/FW穿越技术，它是一种框架，可以整合各种NAT/FW穿越技术如STUN、TURN（Traversal Using Relay NAT 中继NAT实现的穿透）。ICE会先使用STUN，尝试建立一个基于UDP的连接，如果失败了，就会去TCP（先尝试HTTP，然后尝试HTTPS），如果依旧失败ICE就会使用一个中继的TURN（Relay）服务器.Webrtc的ICE穿透如图所示 candidate参考文献–中文博客1 参考文献–中文博客2 参考文献–协议RFC5245 ICE 会在 SDP 中增加传输地址记录值（IP + port + 协议），然后对其进行连通性测试，测试通过之后就可以用于发送媒体数据了。每个记录值都叫做一个 candidate，candidate 可能有三种： 客户端从本机网络接口上获取的地址（host） STUN server 看到的该客户端的地址（server reflexive，缩写为 srflx）； TURN server 为该客户端分配的中继地址（relayed）网络接口地址对应的端口号是客户端自己分配的，如果有多个网络接口地址，那就都要带着。TURN server 可以同时取得 reflexive 和 relayed candidate，而 STUN server 则只能取得 reflexive candidate。两个Peer之间上述三种candidate的任意组合也许都能连通，但实际上很多组合都不可用。例如两个客户端处于两个不同的 NAT 网络后面时，网络接口地址都是内网地址，显然本机网络地址之间是无法连通。而 ICE 的任务，就是找出哪些组合可以连通。怎么找？就是逐个尝试，但不是毫无规则地乱找，而是有条理地、按照某种顺序去逐一尝试。所以P2P穿越的过程会有candidate搜集、candidate排序和candidate使用的过程。","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"p2p","slug":"p2p","permalink":"https://kekbin.com/tags/p2p/"},{"name":"webrtc","slug":"webrtc","permalink":"https://kekbin.com/tags/webrtc/"}]},{"title":"Android位置开发","slug":"android-google-location-develop","date":"2019-07-19T01:25:06.000Z","updated":"2019-08-06T06:20:22.006Z","comments":true,"path":"2019/07/19/android-google-location-develop/","link":"","permalink":"https://kekbin.com/2019/07/19/android-google-location-develop/","excerpt":"","text":"Android位置的API有两种Api都可以为Android设备获取位置 Android location api Google’s location service api 获取位置权限不管使用哪种API，都需要申请位置权限，首先需要在AndroidManifest中声明：1234//精度要求高&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt;//或者精度要求低&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/&gt; 对于target sdk版本大于等于23，且app运行在6.0以上设备上时，需要请求运行时权限 1.检查权限 123public boolean isGrantedLocationPermission() &#123; return ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED);&#125; 2.如果没有权限，则请求权限1234567891011121314151617181920212223242526272829public static final int LOCATION_PERMISSION_REQUEST_CODE = 99;public void requestLocationPermission() &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_FINE_LOCATION)) &#123; // Show an explanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. showExpanation(); &#125; else &#123; // No explanation needed, we can request the permission. doRequestLocationPermission(); &#125;&#125;private void doRequestLocationPermission() &#123; ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.ACCESS_FINE_LOCATION&#125;,MY_PERMISSIONS_REQUEST_LOCATION );&#125;private void showExpanation()&#123; new AlertDialog.Builder(this).setTitle(\"Location Permission Needed\") .setMessage(\"This app needs the Location permission, please accept to use location functionality\") .setPositiveButton(\"OK\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; doRequestLocationPermission(); &#125; &#125;).create().show();&#125; 3.请求结果解析1234567891011121314151617181920212223242526/*** Checks if the result contains a &#123;@link PackageManager#PERMISSION_GRANTED&#125; result for a* permission from a runtime permissions request.** @see android.support.v4.app.ActivityCompat.OnRequestPermissionsResultCallback*/public static boolean isPermissionGranted(String[] grantPermissions, int[] grantResults, String permission) &#123; for (int i = 0; i &lt; grantPermissions.length; i++) &#123; if (permission.equals(grantPermissions[i])) &#123; return grantResults[i] == PackageManager.PERMISSION_GRANTED; &#125; &#125; return false;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); mLocationPermissionGranted = false; if (requestCode != LOCATION_PERMISSION_REQUEST_CODE) &#123; return; &#125; if (PermissionUtil.isPermissionGranted(permissions, grantResults, Manifest.permission.ACCESS_FINE_LOCATION)) &#123; //TODO:do sth,ex connect google service client , get last location, request location &#125;&#125; Android Location API1.Android的位置有三个不同的来源 GPS(LocationManager.GPS_PROVIDER)此提供者使用卫星确定位置。根据条件，此提供程序可能需要一段时间才能返回位置锁定。 NETWORK( LocationManager.NETWORK_PROVIDER)此提供者根据蜂窝基站和WiFi接入点的可用性确定位置。通过网络查找来检索结果。 LocationManager.PASSIVE_PROVIDER其他服务或应用请求位置时，会收到位置的更新 2.基本用法 获取系统LocationManager对象 实现LocationListener回调 调用requestLocationUpdates 1234567891011121314151617LocationManager locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);// Define a listener that responds to location updatesLocationListener locationListener = new LocationListener() &#123; public void onLocationChanged(Location location) &#123; // Called when a new location is found by the network location provider. makeUseOfNewLocation(location); &#125; public void onStatusChanged(String provider, int status, Bundle extras)&#123;&#125; public void onProviderEnabled(String provider) &#123;&#125; public void onProviderDisabled(String provider) &#123;&#125; &#125;;// Register the listener with the Location Manager to receive location updateslocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, locationListener); Google Location Sevice api使用Google Location Service api可以获得更好的电池性能和更精确的准确度。这个api提供Fused Location Provider,可以根据对准确度、电池使用等条件自动选择位置信息的来源；因为Google Service会不断地在后台更新位置信息，所以获取位置的速度也更快。 1.Setting client为了使用由Google Play Services提供的Location Service和Fused Location provider，需要通过Setting Client来确保当前设备的Goolge location service确实可用。如果需要，可以提示用户开启所需的设置 2.从11.0.2版本开始启用FusedLocationProviderClient以往在请求位置变化之前，需要先连接LocationService，需要通过GoogleServicesApiClient进行连接。 过去用GoogleServicesApiClient获取Google APIS（过时的） 12345678910111213141516public void connectGoogleApiClient() &#123; GoogleApiClient mGoogleApiClient = new GoogleApiClient.Builder(this).addConnectionCallbacks(this).addOnConnectionFailedListener(this).addApi(LocationServices.API).build(); mGoogleApiClient.connect();&#125;@Overridepublic void onConnected(Bundle bundle) &#123; //TODO:do sth, ex requestLocationUpdates LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, this);&#125;@Overridepublic void onConnectionSuspended(int i) &#123;&#125;@Overridepublic void onConnectionFailed(ConnectionResult connectionResult) &#123;&#125; 如今，直接获取所需Api的实例，如FusedLocationProviderClient，更方便使用123456private FusedLocationProviderClient fusedLocationClient;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);&#125; 3.获取最新的位置12345678910111213//返回一个持有location结构的taskTask&lt;Location&gt; locationResult = fusedLocationProviderClient.getLastLocation();//locationResult.addOnCompleteListener(this, new OnCompleteListener&lt;Location&gt;() &#123; @Override public void onComplete(@NonNull Task&lt;Location&gt; task) &#123; if (task.isSuccessful()) &#123; // Set the map's camera position to the current location of the device. mLastKnownLocation = task.getResult(); Log.d(TAG, \"Current location, Latitude:\" + mLastKnownLocation.getLatitude() + \"Longitude:\" + mLastKnownLocation.getLongitude()); &#125; &#125;&#125;); 4.接收位置变化 通过requestLocationUpdates可以定期获取位置，它可以根据当前可用的位置提供者、request的参数及精度等提供最合适的位置。在请求位置变化的时候，getLastLocation可以提供一个起始点，代码中常提供一个全局变量mCurrentLocation， 在获取位置变化时， 首先，需要创建一个位置请求1234567protected LocationRequest createLocationRequest() &#123; LocationRequest locationRequest = LocationRequest.create(); locationRequest.setInterval(10000); //间隔10s locationRequest.setFastestInterval(5000); //可以处理的最快间隔 locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY); return locationRequest;&#125; 可选精度包含： PRIORITY_BALANCED_POWER_ACCURACY 100米的误差， 适用于coarse level 的精度，消耗很少的电力，较大可能使用WIFI和蜂窝网络获取位置 PRIORITY_HIGH_ACCURACY 适用于精确位置，常见于GPS定位 PRIORITY_LOW_POWER 提供城市区分的精度，精度在10km左右 PRIORITY_NO_POWER app 不主动请求位置，但是接收其他应用的请求结果 实现一个接收到位置变化的回调 123456789101112LocationCallback mLocationCallback = new LocationCallback() &#123; @Override public void onLocationResult(LocationResult locationResult) &#123; List&lt;Location&gt; locationList = locationResult.getLocations(); if (locationList.size() &gt; 0) &#123; //The last location in the list is the newest Location location = locationList.get(locationList.size() - 1); Log.i(\"MapsActivity\", \"Location: \" + location.getLatitude() + \" \" + location.getLongitude()); mLastLocation = location; &#125; &#125;&#125;; 开始监听位置变化 1234567891011121314@Overrideprotected void onResume() &#123; super.onResume(); if (requestingLocationUpdates) &#123; startLocationUpdates(); &#125;&#125;private void startLocationUpdates() &#123; fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, null /* Looper */); //在线程中执行时，必须指定Looper，且调用Looper.prepare&#125; 关闭监听位置变化 123456789@Overrideprotected void onPause() &#123; super.onPause(); stopLocationUpdates();&#125;private void stopLocationUpdates() &#123; fusedLocationClient.removeLocationUpdates(locationCallback);&#125; 地理位置转换成地址 使用Geocoder类的getFromLocation方法可以将地理位置信息转换为地址，称作为反向地理编码。getFromLocation方法是一个耗时的操作，所以可以创建一个IntentService专门进行操作。 Location And Map这里算是一个综合的应用，将前文所述的一些用法综合起来 获取的位置信息可以在地图上直观地展示出来，这里需要引入Google-location和Google-map服务 引入依赖 12implementation 'com.google.android.gms:play-services-location:16.0.0'implementation 'com.google.android.gms:play-services-maps:16.0.0' 初始化 123456789101112131415161718GoogleMap mGoogleMap;SupportMapFragment mapFrag;LocationRequest mLocationRequest;Location mLastLocation;Marker mCurrLocationMarker;FusedLocationProviderClient mFusedLocationClient;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getSupportActionBar().setTitle(\"Map Location Activity\"); mFusedLocationClient = LocationServices.getFusedLocationProviderClient(this); mapFrag = (SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map); mapFrag.getMapAsync(this); &#125; 等待GoogleMap就绪 如果需要，请在运行时请求位置权限 授予权限后请求位置更新 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void onMapReady(GoogleMap googleMap) &#123; mGoogleMap = googleMap; mGoogleMap.setMapType(GoogleMap.MAP_TYPE_HYBRID); mLocationRequest = createLocationRequest() if (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (isGrantedLocationPermission()) &#123; mFusedLocationClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper()); mGoogleMap.setMyLocationEnabled(true); &#125; else &#123; requestLocationPermission(); &#125; &#125;else &#123; mFusedLocationClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper()); mGoogleMap.setMyLocationEnabled(true); &#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); mLocationPermissionGranted = false; if (requestCode != LOCATION_PERMISSION_REQUEST_CODE) &#123; return; &#125; if (PermissionUtil.isPermissionGranted(permissions, grantResults, Manifest.permission.ACCESS_FINE_LOCATION)) &#123; mLocationPermissionGranted = true; mFusedLocationClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper()); mGoogleMap.setMyLocationEnabled(true); &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. Toast.makeText(this, \"permission denied\", Toast.LENGTH_LONG).show(); &#125;&#125; 获取用户的位置后更新Google地图 为地图添加一个地点标记 1234567891011121314151617181920212223242526LocationCallback mLocationCallback = new LocationCallback() &#123; @Override public void onLocationResult(LocationResult locationResult) &#123; List&lt;Location&gt; locationList = locationResult.getLocations(); if (locationList.size() &gt; 0) &#123; //The last location in the list is the newest Location location = locationList.get(locationList.size() - 1); Log.i(\"MapsActivity\", \"Location: \" + location.getLatitude() + \" \" + location.getLongitude()); mLastLocation = location; if (mCurrLocationMarker != null) &#123; mCurrLocationMarker.remove(); &#125; //Place current location marker LatLng latLng = new LatLng(location.getLatitude(), location.getLongitude()); MarkerOptions markerOptions = new MarkerOptions(); markerOptions.position(latLng); markerOptions.title(\"Current Position\"); markerOptions.icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_MAGENTA)); mCurrLocationMarker = mGoogleMap.addMarker(markerOptions); //move map camera mGoogleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, 15)); &#125; &#125;&#125;; Google Api Key 首先你需要有一个Goolge账号 进入google-api 后台 创建一个项目 启用Api 在侧边栏的Api和服务-&gt;库启用你所需要的api接口，如本项目需要启用Maps SDK for Android、 获取api key 在Api和服务-&gt; 凭据，创建API key 限制和重命名密钥 为防止密钥被盗用，正式项目需要为api key做一些限制，具体方法见文档 使用密钥:在manifest文件中声明123&lt;meta-data android:name=&quot;com.google.android.geo.API_KEY&quot; android:value=&quot;@string/google_maps_key&quot; /&gt; 参考文献参考文献1 参考文献2 参考文献3 参考文献4 参考文献5 参考文献6","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://kekbin.com/tags/Android/"},{"name":"google","slug":"google","permalink":"https://kekbin.com/tags/google/"},{"name":"location","slug":"location","permalink":"https://kekbin.com/tags/location/"}]},{"title":"NAS + DPFS-IPFS家庭云管理方案","slug":"NAS-DPFS","date":"2018-07-16T07:02:03.000Z","updated":"2019-07-19T05:57:21.636Z","comments":true,"path":"2018/07/16/NAS-DPFS/","link":"","permalink":"https://kekbin.com/2018/07/16/NAS-DPFS/","excerpt":"","text":"概述DPFS是经过改造后的IPFS私网，运行在手机端的IPFS管理功能。NAS家庭云，拥有的大存储是作为IPFS节点的天然属性，另外其局域网内互联互通，和广域网外访问的属性，为DPFS添加和和个人主页的访问提供了良好的途径。NAS+IPFS做为文件的存储节点，通过DPFS把移动终端的文件add到NAS/IPFS节点上，并做name publish绑定到DPFS node peerId，然后即可通过ipfs gateway查看文件列表，并获取文件。下图简介了NAS+DPFS的方案。 具体细节如下： 手机A安装DPFS demo NAS上部署改造后的IPFS进程 手机A和NAS在同一个局域网时，通过DPFS向NAS上add一个或多个文件，并做name publish 其他设备（手机、PC、笔记本….）无论在何时何处都可以通过个人主页（http:///ipns/DPFSnodePeerId）查看所有在NAS/IPFS节点上的文件，也可以随时查看和下载所有文件 示例手机端DPFS demo上传文件到NAS 1.长按需要上传的文件，弹出menu2.点击‘Add to home page’即可执行add操作3.更新完成 4.可以通过如下url查看添加到nas上的文件http://210.73.213.194:8080/ipns/QmSyv5FikH4b8ihrbBXQBe6z8bZr2fUP1Ta4jMeFBHyRWf","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"IPFS","slug":"IPFS","permalink":"https://kekbin.com/tags/IPFS/"},{"name":"p2p","slug":"p2p","permalink":"https://kekbin.com/tags/p2p/"}]},{"title":"P2P网络由浅入深—基于局域网模型","slug":"p2p-network-1","date":"2018-06-26T08:43:53.000Z","updated":"2019-08-06T06:20:24.298Z","comments":true,"path":"2018/06/26/p2p-network-1/","link":"","permalink":"https://kekbin.com/2018/06/26/p2p-network-1/","excerpt":"","text":"最近开始接触IPFS，前面博文中也略有提到过，它是一个去中心化的分布式网络文件系统。其核心之一就是P2P网络（peer-to-peer network），可以说P2P网络是IPFS的基础。IPFS项目组为P2P网络构建了一个单独的开源项目libp2p,使其不仅可以用在IPFS项目中，也可以用于构建其他的P2P网络。 p2p网络与中心化网络本文不想对两者的优劣进行比较，因为目前似乎比较它们的优劣也没有任何意义，毕竟现实情景下，两者是无法互相替代的。至少目前热点追捧的去中心化，还无法替代中心化的功能。 计算机网络的初衷就是建立一个相互通信的对等的计算机网络，但是由于历史问题连接在网络的计算机配置不高，计算能力和存储能力不足，因此相当长一段时间我们更倾向于使用基于客户端（client）和服务器（server）的C/S模式及浏览器（Browser）和服务器（server）的B/S模式: 在libp2p的白皮书中，列举了如下选用cs建构的理由： The bandwidth inside a data center is considerably higher than that available for clients to connect to each other. Data center resources are considerably cheaper, due to efficient usage and bulk stocking. It makes it easier for the developer and system admin to have fine grained control over the application. It reduces the number of heterogeneous systems to be handled (although the number is still considerable). Systems like NAT make it really hard for client machines to find and talk with each other, forcing a developer to perform very clever hacks to traverse these obstacles. Protocols started to be designed with the assumption that a developer will create a client-server application from the start. 简单地概括就是高带宽、低成本、易维护、穿透性强、易开发。其实这些理由也只是相对而言，例如低成本，服务器打带宽和电费支出，远高于对等节点的支出。所谓易维护，如果所有服务器宕机的话，这个服务是暂停的。 当然上图只是简单的示意，具体P2P的网络拓扑远比图示更多样、更复杂。P2P网络中的所有节点都是对等的，各台计算机有相同的功能，无主从之分，一台计算机既可作为服务器，设定共享资源供网络中其他计算机所使用，又可以作为工作站，整个网络一般来说不依赖专用的集中服务器，也没有专用的工作站。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求做出响应，提供资源、服务和内容。 听起来，比中心化的网络更加诱人对吧。这样的对等网络需要解决的事情还有很多，如NAT后面的节点彼此发现和可达、各个节点的吞吐量是否能达到人们对性能的可忍受度。 基于局域网环境的P2P模型之前一直在做局域网的文件传输工具的开发，其实局域网文件传输所需建立的网络，从广泛意义上讲，也是一个P2P的网络，只不过它的情况会比广域网上的P2P要简单的多。 无需考虑NAT穿透，因为每个节点都是在同一个网关下 节点彼此发现简单 拓扑简单 但是简单的网络结构也需要实现P2P网络的几个关键问题 节点路由本文的前提是在同一个局域网下，所以路由的问题就比较简单了，所有的数据传输经路由器转发。 此处不必把路由器和中心化服务器进行混淆，路由器在这里只充当网络数据的桥梁，对网络中所有的数据进行透传。 节点之间的发现网络中的节点，起初就像是不认识的陌生人，互相是不知道对方的任何信息的。所以，如果要知道网络中某个节点的具体信息，甚至是传输东西给对方，就需要有一个沟通的途径，让彼此能够发现自己。以往我们做的众多的局域网传输的经验中，有以下几种方式，能够发现设备： 热点发现 类似于WIFI的发现机制，通过无线电信号，发现方启动热点扫描，发现热点设备。发现之后，这样热点的启动设备和发现设备就组成了一个1对1的网络。但是如果多个设备都连入这个热点，启动热点的设备，就变成一个路由，所有其它节点之间的消息都需要热点设备进行转发，因此它已经丧失了P2P的意义。 蓝牙发现 借助蓝牙的发现机制，发现对方，然后通过蓝牙通信告知网络基本信息及地址。 UDP广播 网络中的节点通过某个端口不断地向全网广播自己的信息，网络中的所有节点都监听这个端口，这样收到广播的节点可以进行回复，这样双方就知道对方的基本信息和地址。为了网络信息的安全性，可以对信息进行加密，这样非恶意节点才可以解密该信息。额外的风险在于，恶意节点也可以不断地向该端口发送广播，污染网络，使消息阻塞，无法扫描发现。如消息格式： 1magic(4)| sequence(8) | version(1) | type(1) | enc(body) 节点连接发现节点之后，彼此了解了各自的地址（如IP），在局域网中，就可以通过ip和固定端口直接建立TCP连接。 节点数据交互连接之后可以建立信令通道，传递控制信息。控制通道上跑的信息可以是自定义的任何这个网络中所有节点认可的协议，传递二进制、JSON等数据皆可。 另外在文件共享的网络中，还必须有一个数据通道，用于交互数据信息。 数据通道中用于传输文件的协议会有很多中选择，如HTTP(HTTPS)、FTP、MTP等。 在这个简单的P2P网络中，每一个节点即是server端（如Http server），用于发送文件，也可以是client端（如http client），用于请求文件内容。所有节点都是对等的。文件服务无需借助于一个云服务单元来上传下载。 以上的所讲局域网络模型，对真实的P2P网络其实有很大的不同，但是具有理解上的借鉴意义。当中可能也有些不够准确的地方，随着学习的了解的深入，慢慢剖析吧。","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"IPFS","slug":"IPFS","permalink":"https://kekbin.com/tags/IPFS/"},{"name":"p2p","slug":"p2p","permalink":"https://kekbin.com/tags/p2p/"},{"name":"libp2p","slug":"libp2p","permalink":"https://kekbin.com/tags/libp2p/"}]},{"title":"简单合同管理程序开发记录","slug":"simple_cm_wiki","date":"2018-06-24T16:00:00.000Z","updated":"2019-07-19T05:58:27.677Z","comments":true,"path":"2018/06/25/simple_cm_wiki/","link":"","permalink":"https://kekbin.com/2018/06/25/simple_cm_wiki/","excerpt":"","text":"最近一个朋友表示，他们公司的合同用Excel管理，多了之后变得很麻烦，让我帮他做个合同管理的小工具，利用最近的闲暇时间，用WPF写了一个小工具。 需求微信上简单的聊天，把他一堆不太具象的想法归纳起来，罗列需求，化成思维导图比较清晰了。 开发环境由于朋友的电脑都使用的windows，所以采用vs2017 + WPF的开发桌面应用是比较方便的选择。 模块划分 UI 采用Blend 2017画一个简单的UI图，然后在稍修改xaml文件，UI便可成型 数据模型由于WPF采用MVVM的模式，数据模型只需实现INotifyPropertyChanged接口即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309namespace SimpleCM.Data&#123; public class Contract: INotifyPropertyChanged &#123; public long Id &#123; get; set; &#125; private string _contractNumber; public string ContractNumber &#123; set &#123; _contractNumber = value; OnPropertyChanged(\"ContractNumber\"); &#125; get =&gt; _contractNumber; &#125; private string _projectCategory; public string ProjectCategory &#123; get =&gt; _projectCategory; set &#123; _projectCategory = value; OnPropertyChanged(\"ProjectCategory\"); &#125; &#125; private string _contractName; public string ContractName &#123; set &#123; _contractName = value; OnPropertyChanged(\"ContractName\"); &#125; get =&gt; _contractName; &#125; private long _contractDate; public long ContractDate &#123; set &#123; _contractDate = value; OnPropertyChanged(\"ContractDate\"); &#125; get =&gt; _contractDate; &#125; private string _projectDescription; public string ProjectDescription &#123; set &#123; _projectDescription = value; OnPropertyChanged(\"ProjectDescription\"); &#125; get =&gt; _projectDescription; &#125; private string _contractCompany; public string ContractCompany &#123; set &#123; _contractCompany = value; OnPropertyChanged(\"ContractCompany\"); &#125; get =&gt; _contractCompany; &#125; private string _cooperatorCompany; public string CooperatorCompany &#123; set &#123; _cooperatorCompany = value; OnPropertyChanged(\"CooperatorCompany\"); &#125; get =&gt; _cooperatorCompany; &#125; private long _cost; public long Cost &#123; set &#123; _cost = value; OnPropertyChanged(\"Cost\"); &#125; get =&gt; _cost; &#125; private long _peceivables_1; public long Peceivables_1 &#123; get =&gt; _peceivables_1; set &#123; _peceivables_1 = value; OnPropertyChanged(\"Peceivables_1\"); &#125; &#125; private long _peceivables_2; public long Peceivables_2 &#123; get =&gt; _peceivables_2; set &#123; _peceivables_2 = value; OnPropertyChanged(\"Peceivables_2\"); &#125; &#125; private long _peceivables_3; public long Peceivables_3 &#123; get =&gt; _peceivables_3; set &#123; _peceivables_3 = value; OnPropertyChanged(\"Peceivables_3\"); &#125; &#125; private string _baseInfo; readonly string format = \"项目编号:&#123;0&#125;\\n项目名称:&#123;1&#125;\\n项目类别:&#123;2&#125;\\n项目日期:&#123;3&#125;\\n\" + \"签约单位:&#123;4&#125;\\n合作单位:&#123;5&#125;\\n项目描述:&#123;6&#125;\\n总费用:&#123;7&#125;\\n\" + \"应付款项一:&#123;8&#125;\\n应付款项二:&#123;9&#125;\\n应付款项三&#123;10&#125;\"; public string BaseInfo &#123; get &#123; DateTime datetime = Util.GetTimeFromMillis(ContractDate); string dateInfo = string.Format(\"&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日\", datetime.Year, datetime.Month, datetime.Day); return string.Format(format, ContractNumber, ContractName, ProjectCategory, dateInfo, ContractCompany, CooperatorCompany, ProjectDescription, Cost, Peceivables_1,Peceivables_2, Peceivables_3); &#125; set &#123; _baseInfo = value; OnPropertyChanged(\"BaseInfo\"); &#125; &#125; private string _aditionals; public string Aditionals &#123; get =&gt; _aditionals; set &#123; _aditionals = value; OnPropertyChanged(\"Aditionals\"); &#125; &#125; public ObservableCollection&lt;string&gt; AddtionList &#123; get &#123; ObservableCollection&lt;string&gt; list = new ObservableCollection&lt;string&gt;(); if (!string.IsNullOrEmpty(_aditionals)) &#123; string[] infos = _aditionals.Split(' '); if (infos != null &amp;&amp; infos.Length &gt; 0) &#123; for (int i = 0; i &lt; infos.Length; i++) &#123; list.Add(infos[i]); &#125; &#125; &#125; return list; &#125; &#125; public string BillNoteTostring() &#123; //不能加@,否则原样输出\\r\\n,不换行 string format = \"公司名称:&#123;0&#125;\\n纳税人识别号:&#123;1&#125;\\n地址:&#123;2&#125;\\n电话:&#123;3&#125;\\n银行:&#123;4&#125;\\n账号:&#123;5&#125;\"; return string.Format(format, BillNoteCompanyName, BillNoteTaxFileNum, BillNoteAddress, BillNotePhoneNumber, BillNoteBank, BillNoteBankAccount); &#125; public void FromBillNoteString() &#123; string[] noteItems = _billNoteInfo.Split('\\n'); if (noteItems != null &amp;&amp; noteItems.Length == 6) &#123; BillNoteCompanyName = noteItems[0].Substring(noteItems[0].IndexOf(':') + 1); BillNoteTaxFileNum = noteItems[1].Substring(noteItems[1].IndexOf(':') + 1); BillNoteAddress = noteItems[2].Substring(noteItems[2].IndexOf(':') + 1); BillNotePhoneNumber = noteItems[3].Substring(noteItems[3].IndexOf(':') + 1); BillNoteBank = noteItems[4].Substring(noteItems[4].IndexOf(':') + 1); BillNoteBankAccount = noteItems[5].Substring(noteItems[5].IndexOf(':') + 1); &#125; &#125; private string _billNoteInfo; public string BillNoteInfo &#123; get =&gt; _billNoteInfo; set &#123; _billNoteInfo = value; OnPropertyChanged(\"BillNoteInfo\"); &#125; &#125; private string _billNoteCompanyName; public string BillNoteCompanyName &#123; get &#123; return _billNoteCompanyName; &#125; set &#123; _billNoteCompanyName = value; OnPropertyChanged(\"BillNoteCompanyName\"); &#125; &#125; private string _billNoteTaxFileNum; public string BillNoteTaxFileNum &#123; get &#123; return _billNoteTaxFileNum; &#125; set &#123; _billNoteTaxFileNum = value; OnPropertyChanged(\"BillNoteTaxFileNum\"); &#125; &#125; private string _billNoteAddress; public string BillNoteAddress &#123; get &#123; return _billNoteAddress; &#125; set &#123; _billNoteAddress = value; OnPropertyChanged(\"BillNoteAddress\"); &#125; &#125; private string _billNotePhoneNumber; public string BillNotePhoneNumber &#123; get &#123; return _billNotePhoneNumber; &#125; set &#123; _billNotePhoneNumber = value; OnPropertyChanged(\"BillNotePhoneNumber\"); &#125; &#125; private string _billNoteBank; public string BillNoteBank &#123; get &#123; return _billNoteBank; &#125; set &#123; _billNoteBank = value; OnPropertyChanged(\"BillNoteBank\"); &#125; &#125; private string _billNoteBankAccount; public string BillNoteBankAccount &#123; get &#123; return _billNoteBankAccount; &#125; set &#123; _billNoteBankAccount = value; OnPropertyChanged(\"BillNoteBankAccount\"); &#125; &#125; public override string ToString() =&gt; ContractName; public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged(string info) &#123; var handler = PropertyChanged; handler?.Invoke(this, new PropertyChangedEventArgs(info)); &#125; &#125;&#125; 持久化存储采用sqlite3进行存储 数据绑定 12&lt;ListBox x:Name=\"contract_list_box\" Grid.Row=\"1\" HorizontalAlignment=\"Left\" Width=\"250\" Margin=\"20\" IsSynchronizedWithCurrentItem=\"True\" ItemsSource=\"&#123;Binding Source=&#123;x:Static util:Contracts.Instance&#125;&#125;\"&gt; 1234567891011121314using System.Collections.ObjectModel;namespace SimpleCM.Data&#123; class Contracts: ObservableCollection&lt;Contract&gt; &#123; public static Contracts Instance &#123; get; &#125; = new Contracts(); public void AddContact(Contract c) &#123; Add(c); ContractDB.Instance.InsertItem(c); &#125; &#125;&#125; 代码Github链接","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"c-sharp","slug":"c-sharp","permalink":"https://kekbin.com/tags/c-sharp/"},{"name":"wpf","slug":"wpf","permalink":"https://kekbin.com/tags/wpf/"},{"name":"open-source","slug":"open-source","permalink":"https://kekbin.com/tags/open-source/"}]},{"title":"javascript学习笔记1","slug":"javascript-study-1","date":"2018-06-14T11:05:17.000Z","updated":"2019-07-19T05:56:46.993Z","comments":true,"path":"2018/06/14/javascript-study-1/","link":"","permalink":"https://kekbin.com/2018/06/14/javascript-study-1/","excerpt":"","text":"变量null 用于对象, undefined 用于变量，属性和方法。 对象只有被定义才有可能为 null，否则为 undefined。 undefined：表示变量未赋值，未定义的类型 null：用于清空的对象值, 类型是object 123456789101112&lt;script&gt; var person;//undefined person = &#123;name:\"bob\", phone:\"1344444\"&#125;; person = null; typeof person;//object person = undefined;//typeof person = undefined var h = &#123;name:\"lisi\", age:29&#125;; console.log(h.name); console.log(h[name]); var arr =['a', 3. 'hello', true;] alert(arr);&lt;/script&gt; 运算符1234567891011&lt;script&gt;//一旦遇到非数值型的，后面一律字符串拼接 console.log(2+3+4+'haha'+5+6)//9haha56 //js中逻辑运算返回的是最早能判断表达式结果的那个值 var a = false var b = 6 var c = true; console.log(a || b || c) //输出6 console.log(a &amp;&amp; b &amp;&amp; c) //输出false&lt;/script&gt; 控制结构1234var obj = &#123;name:'lisi', age:29, area:'cn'&#125;for(var k in obj) &#123; console.log(k + \"~\" + obj[k]);&#125; 普通对象操作 属性 方法 静态方法 1234var dt = new Date()var str = \"hell\"str.lengthMath.random() *5 + 5 //5 ~ 10 Window对象操作1234567891011121314//浏览器对象window.alert()window.confirm()//window子对象-如判断浏览器是否支持cookiewindow.navigator.cookieEnabled//window地址栏子对象,如跳转地址栏window.location.href = 'http://www.baidu.com';//window子对象-历史记录window.history.forward();window.history.back();//屏幕对象window.screen//DOM对象-页面的文档window.docment 判断对象“john”.constructor返回构造函数，如String() { [native code] } 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;判断是否为数组。&lt;/p&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];document.getElementById(\"demo\").innerHTML = isArray(fruits);function isArray(myArray) &#123; return myArray.constructor.toString().indexOf(\"Array\") &gt; -1;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 变量的作用域var是声明一个局部变量不加var是赋值，会污染全局首先在函数内部找，找不到会一直找最外层的变量 123456789window.str = 'global';function t1() &#123; function t2() &#123; str = 'b' &#125; t2();&#125;t1();alert(window.str);//全局被污染，此时str=b DOM对象例子123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='utf-8'&gt;&lt;title&gt;第一个特效&lt;/title&gt;&lt;style&gt; #test1&#123; width:300px; height:200px; background:red; &#125; #test2&#123; width:300px; height:200px; background:blue; &#125;&lt;/style&gt;&lt;script&gt; function change()&#123; var div = document.getElementById('test1'); div.id = 'test2'; &#125;&lt;/script&lt;/head&gt;&lt;body&gt; &lt;h1&gt;特效是什么&lt;/h1&gt; &lt;div id='test1' onclick='change()'&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 找到DOM对象123456789101112131415//根据Id来找，返回dom对象document.getElementById('test');//根据标签来找-返回对象的集合document.getElementsByTagName('p');//对于表单元素，用name来查找,返回对象集合，比如文字框，按钮document.getElementsByName('username');//按照类名查找，返回对象集合document.getElementsByClassName('classname');//找子节点，包含空白节点document.getElementById('test').childNodes//非标准属性，但兼容性好，不包含空白节点document.getElementById('test').children//父节点document.getElementsByTagName('p')[2].parentNode; 操作对象属性以img为例 1&lt;img src=\"a.jpg\" alt='' title='1' style='width:200px;height:200px;'&gt; object.src 标签属性 object.alt 标签属性 object.title 标签属性 object.style 对象属性 object.style.widith css属性中带有横线的，用大写字母替代如border-top-style用obj.style.borderTopStyle class标签的属性为.className 示例：1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='utf-8'&gt;&lt;title&gt;第二个特效&lt;/title&gt;&lt;style&gt; .test1&#123; background:red; &#125; .test2&#123; background:green; &#125;&lt;/style&gt;&lt;script&gt; function change()&#123; var div = document.getElementsByTagName('div')[0]; if (div.className.indexOf('test1') &gt;=0)&#123; div.className = 'test2'; &#125;else if (div.className.indexOf('test2') &gt;=0)&#123; div.className = 'test1'; &#125; div.style.width = parseInt(div.style.width) + 5 + 'px'; div.style.height = parseInt(div.style.height) + 5 + 'px'; div.style.borderBottomWidth = parseInt(div.style.borderBottomWidth) + 1 + 'px' &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='test1' onclick='change()' style='width:200px;height:200px;border-bottom:1px solid black;'&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 获取运行时的style对象获取的属性是只读的1234//IE9以下使用obj.currentStylefunction getStyle(obj, attr) &#123; return obj.currentStyle? obj.currentStyle[attr] :window.getComputedStyle(obj, null)[attr];&#125; 因此之前的可以将style写在css中了12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='utf-8'&gt;&lt;title&gt;第二个特效&lt;/title&gt;&lt;style&gt; div&#123; width:200px; height:200px; border-bottom:1px solid black; &#125; .test1&#123; background:red; &#125; .test2&#123; background:green; &#125;&lt;/style&gt;&lt;script&gt; function getStyle(obj, attr) &#123; return obj.currentStyle? obj.currentStyle[attr] :window.getComputedStyle(obj, null)[attr]; &#125; function change()&#123; var div = document.getElementsByTagName('div')[0]; if (div.className.indexOf('test1') &gt;=0)&#123; div.className = 'test2'; &#125;else if (div.className.indexOf('test2') &gt;=0)&#123; div.className = 'test1'; &#125; div.style.width = parseInt(getStyle(div, 'width')) + 5 + 'px'; div.style.height = parseInt(getStyle(div, 'height')) + 5 + 'px'; div.style.borderBottomWidth = parseInt(getStyle(div, 'borderBottomWidth')) + 1 + 'px' &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='test1' onclick='change()'&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 删除节点 找到对象childobj 找到父对象parentobj parentobj.removeChild(childobj) 示例123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='utf-8'&gt;&lt;title&gt;第三个特效&lt;/title&gt;&lt;script&gt; function delLast()&#123; var lis = document.getElementsByTagName('li'); var lastLi = lis[lis.length-1]; lastLi.parentNode.removeChild(lastLi); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type='button' value='del last' onclick='delLast()'/&gt;&lt;ul&gt; &lt;li&gt;春&lt;/li&gt; &lt;li&gt;夏&lt;/li&gt; &lt;li&gt;秋&lt;/li&gt; &lt;li&gt;冬&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 创建节点 创建对象obj 找到父对象 parentObj parentObj.appendChild 123456789function add() &#123; var li = document.createElement('li'); var txt = document.createTextNode('冬'); li.appendChild(txt); var parent = document.getElementsByTagName('ul')[0]; parent.appendChild(li);&#125; 暴力操作节点innerHTML 12val ul = document.getElementsByTagName('ul')[0];ul.innerHTML = '&lt;li&gt;春&lt;/li&gt;&lt;li&gt;夏&lt;/li&gt;''; 联动菜单事件+DOM操作 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='utf-8'&gt;&lt;title&gt;联动菜单&lt;/title&gt;&lt;script&gt; var area =[['郑州' , '信阳' , '洛阳'], ['南京','无锡','苏州']] function ld()&#123; var sel = document.getElementById('province'); var selcity = document.getElementById('city'); var opt = ''; if (sel.value &lt; 0) &#123; selcity.innerHTML = opt; return; &#125; for (var i = 0, len = area[sel.value].length; i &lt; len; i++) &#123; opt = opt + \"&lt;option value = ' + i + '&gt;\" + area[sel.value][i] + '&lt;/option&gt;'; &#125; selcity.innerHTML = opt; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;select id='province' onchange='ld();'&gt; &lt;option value='-1'&gt;请选择&lt;/option&gt; &lt;option value='0'&gt;河南&lt;/option&gt; &lt;option value='1'&gt;江苏&lt;/option&gt;&lt;/select&gt;&lt;select id='city'/&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://kekbin.com/categories/笔记/"}],"tags":[{"name":"html","slug":"html","permalink":"https://kekbin.com/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"https://kekbin.com/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://kekbin.com/tags/web/"}]},{"title":"IPFS实践之功能封装","slug":"IPFS-practice-2","date":"2018-06-07T03:05:24.000Z","updated":"2019-07-19T05:56:20.703Z","comments":true,"path":"2018/06/07/IPFS-practice-2/","link":"","permalink":"https://kekbin.com/2018/06/07/IPFS-practice-2/","excerpt":"","text":"在IPFS实践之初体验中以命令行的方式演示了如何使用IPFS的基础命令。然而，如果基于IPFS做二次开发应用程序，就需要对这些功能进行封装。本文介绍两种调用IPFS功能的方式。 Cmd以C#为例，采用启动cmd进程的方式调用命令行,命令行执行程序如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public const int WAIT_FOR_EXIT = 2 * 60 * 000;public const int CRASH_EXIT_CODE = 0xFFFF;public static int RunExe(string exeFileName, string args, out string output)&#123; output = \"\"; int iCode = CRASH_EXIT_CODE; if (exeFileName == null) &#123; return CRASH_EXIT_CODE; &#125; ProcessStartInfo procInfo = new ProcessStartInfo &#123; FileName = exeFileName, Arguments = args, RedirectStandardOutput = true, CreateNoWindow = true, UseShellExecute = false, &#125;; Process exeProc = null; StreamReader reader = null; try &#123; exeProc = Process.Start(procInfo); if (exeProc == null) &#123; return CRASH_EXIT_CODE; &#125; if (exeProc.StandardOutput != null &amp;&amp; exeProc.StandardOutput.BaseStream != null) &#123; output = exeProc.StandardOutput.ReadToEnd(); &#125; if (exeProc != null) &#123; if (exeProc.WaitForExit(WAIT_FOR_EXIT)) &#123; iCode = exeProc.ExitCode; &#125; int cnt = 0; while (!exeProc.HasExited &amp;&amp; cnt++ &lt; 15) &#123; Thread.Sleep(5); &#125; exeProc.Close(); &#125; &#125; catch (Exception e) &#123; iCode = CRASH_EXIT_CODE; &#125; finally &#123; DisposeResource(reader); &#125; return iCode;&#125; 有了以上的封装，那么执行ipfs add的调用代码可以是 12string args = string.Format(\"add &#123;0&#125;\", filepath)ScriptTool.RunExe(\"ipfs\", args, out output); 这样的方式，有几种弊端： 由于每执行一条命令都需要启动一个进程，而这些进程是互斥的，在IPFS repo下，有一个repo_lock,导致同时命令多条执行的失败率很高。 由于命令行执行时，执行完成的输出都是字符串，处理起来比较麻烦。 Http Api之前提过，官方提供的go-ipfs实现的demo中提供了http api的功能，也就是说所有的IPFS功能都可以通过http请求的方式来实现，http接口详见http API docs以http api的方式执行，可以完美解决cmd的问题： 它无需另起进程，可以使用多线程，同时执行多条指令 api的返回是一个json string，方便解析我们所需要的结果参数。 还是以ipfs add为例，接口说明如下： /api/v0/addAdd a file or directory to ipfs.Argumentsarg [file]: The path to a file to be added to ipfs. Required: yes.recursive [bool]: Add directory paths recursively. Default: “false”. Required: no.quiet [bool]: Write minimal output. Required: no.quieter [bool]: Write only final hash. Required: no.silent [bool]: Write no output. Required: no.progress [bool]: Stream progress data. Required: no.trickle [bool]: Use trickle-dag format for dag generation. Required: no.only-hash [bool]: Only chunk and hash - do not write to disk. Required: no.wrap-with-directory [bool]: Wrap files with a directory object. Required: no.hidden [bool]: Include files that are hidden. Only takes effect on recursive add. Required: no.chunker [string]: Chunking algorithm to use. Required: no.pin [bool]: Pin this object when adding. Default: “true”. Required: no.raw-leaves [bool]: Use raw blocks for leaf nodes. (experimental). Required: no.nocopy [bool]: Add the file using filestore. (experimental). Required: no.fscache [bool]: Check the filestore for pre-existing blocks. (experimental). Required: no.cid-version [int]: Cid version. Non-zero value will change default of ‘raw-leaves’ to true. (experimental). Default: “0”. Required: no.hash [string]: Hash function to use. Will set Cid version to 1 if used. (experimental). Default: “sha2-256”. Required: no.Request BodyArgument “path” is of file type. This endpoint expects a file in the body of the request as ‘multipart/form-data’.ResponseOn success, the call to this endpoint will return with 200 and the following body:{ “Name”: “[string]” “Hash”: “[string]” “Bytes”: “[int64]” “Size”: “[string]”} 所以add一个文件,需要用post的方式，通过mutipart/form-data格式提交文件内容这个请求的url：http://localhost:5001/api/v0/add?recursive=false其中上传文件夹的时候，recursive参数需要设置为true。 Mutipart上传代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public static string HttpMultiPartPost(string url, int timeOut, string path, bool isDir)&#123; string responseContent; var webRequest = (HttpWebRequest)WebRequest.Create(url); // 边界符 var boundary = \"---------------\" + DateTime.Now.Ticks.ToString(\"x\"); // 边界符 var beginBoundary = Encoding.ASCII.GetBytes(\"\\r\\n\" + \"--\" + boundary + \"\\r\\n\"); // 最后的结束符 var endBoundary = Encoding.ASCII.GetBytes(\"\\r\\n\" + \"--\" + boundary + \"--\\r\\n\"); // 设置属性 webRequest.Method = \"POST\"; webRequest.Timeout = timeOut; webRequest.ContentType = \"multipart/form-data; boundary=\" + boundary; var requestStream = webRequest.GetRequestStream(); if (isDir) &#123; //发送分割符 requestStream.Write(beginBoundary, 0, beginBoundary.Length); //发送文件夹头 const string folderHeaderFormat = \"Content-Disposition: file; filename=\\\"&#123;0&#125;\\\"\\r\\n\" + \"Content-Type: application/x-directory\\r\\n\\r\\n\"; var folderHeader = string.Format(folderHeaderFormat, GetDirectoryName(path)); var headerbytes = Encoding.UTF8.GetBytes(folderHeader); requestStream.Write(headerbytes, 0, headerbytes.Length); DirectoryInfo directory = new DirectoryInfo(path); FileInfo[] fileInfo = directory.GetFiles(); foreach (FileInfo item in fileInfo) &#123; PostFileItem(requestStream, beginBoundary, item, GetDirectoryName(path)); &#125; &#125; else &#123; PostFileItem(requestStream, beginBoundary, new FileInfo(path), null); &#125; // 写入最后的结束边界符 requestStream.Write(endBoundary, 0, endBoundary.Length); requestStream.Close(); var httpWebResponse = (HttpWebResponse)webRequest.GetResponse(); using (var httpStreamReader = new StreamReader(httpWebResponse.GetResponseStream(),Encoding.GetEncoding(\"utf-8\"))) &#123; responseContent = httpStreamReader.ReadToEnd(); &#125; httpWebResponse.Close(); webRequest.Abort(); return responseContent;&#125;private static void PostFileItem(Stream stream, byte[] boundary, FileInfo fileInfo, string dirName)&#123; string name = fileInfo.Name; if (!string.IsNullOrEmpty(dirName)) &#123; name = dirName + \"/\" + name; &#125; //发送分割符 stream.Write(boundary, 0, boundary.Length); //发送文件头 const string headerFormat = \"Abspath: &#123;0&#125;\\r\\n\" + \"Content-Disposition: file; filename=\\\"&#123;1&#125;\\\"\\r\\n\" + \"Content-Type: application/octet-stream\\r\\n\\r\\n\"; var header = string.Format(headerFormat, fileInfo.FullName, name); var headerbytes = Encoding.UTF8.GetBytes(header); stream.Write(headerbytes, 0, headerbytes.Length); //发送文件流 var fileStream = new FileStream(fileInfo.FullName, FileMode.Open, FileAccess.Read); var buffer = new byte[1024]; int bytesRead; // =0 while ((bytesRead = fileStream.Read(buffer, 0, buffer.Length)) != 0) &#123; stream.Write(buffer, 0, bytesRead); &#125; fileStream.Close();&#125; add Api调用代码如下： 123456789101112131415161718192021public static string Add(string path, bool isDir)&#123; if (string.IsNullOrEmpty(path)) &#123; return null; &#125; string format = \"\"; if (isDir) &#123; format = \"&#123;0&#125;?chunker=size-262144&amp;recursive=true\"; &#125; else &#123; //如果需要保存名字，需要wrap一个dir //format = \"&#123;0&#125;?chunker=size-262144&amp;recursive=false&amp;wrap-with-directory=true\"; format = \"&#123;0&#125;?chunker=size-262144&amp;recursive=false\"; &#125; string url = string.Format(format, \"http://localhost:5001/api/v0/add\"); string output = HttpMultiPartPost(url, 500000, path, isDir); return output;&#125; 大部分的api都是以get的方式请求，相比add简单许多，这里提供一个C#的httpget方法供参考. 123456789101112131415public static string HttpGet(string url, int timeOut)&#123; string responseContent; var webRequest = (HttpWebRequest)WebRequest.Create(url); webRequest.Method = \"GET\"; webRequest.Timeout = timeOut; var httpWebResponse = (HttpWebResponse)webRequest.GetResponse(); using (var httpStreamReader = new StreamReader(httpWebResponse.GetResponseStream(), Encoding.GetEncoding(\"utf-8\"))) &#123; responseContent = httpStreamReader.ReadToEnd(); &#125; httpWebResponse.Close(); webRequest.Abort(); return responseContent;&#125; 如name publish这样的操作就可以这样调用 1234567public static string NamePublish(string hash, int hours)&#123; //lifetime失效期 string format = \"&#123;0&#125;?arg=&#123;1&#125;&amp;lifetime=&#123;2&#125;h\"; string url = string.Format(format, @\"http://localhost:5001/api/v0/name/publish\", hash, hours); return HttpTool.HttpGet(url, 100000);&#125; 封装了这些操作，我们就可以将IPFS用起来，做一些我们所需要的application。","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"IPFS","slug":"IPFS","permalink":"https://kekbin.com/tags/IPFS/"},{"name":"c-sharp","slug":"c-sharp","permalink":"https://kekbin.com/tags/c-sharp/"}]},{"title":"IPFS实践之初体验","slug":"IPFS-practice-1","date":"2018-06-06T03:05:24.000Z","updated":"2019-08-06T06:20:23.462Z","comments":true,"path":"2018/06/06/IPFS-practice-1/","link":"","permalink":"https://kekbin.com/2018/06/06/IPFS-practice-1/","excerpt":"","text":"概述IPFS的全称是InterPlanetary File System（星际文件系统），从名称上看，这是一个很炫酷、很有野心的项目。简单地说它就是一个点对点的分布式文件系统。官网和github都可以找到所有的相关资料。建议从它的白皮书，和直译中文版本开始了解，后面我们会慢慢地认识它。白皮书上指出了多个应用场景： As a mounted global filesystem, under /ipfs and /ipns. As a mounted personal sync folder that automaticallyversions, publishes, and backs up any writes. As an encrypted file or data sharing system. As a versioned package manager for all software. As the root filesystem of a Virtual Machine. As the boot filesystem of a VM (under a hypervisor). As a database: applications can write directly to theMerkle DAG data model and get all the versioning,caching, and distribution IPFS provides. As a linked (and encrypted) communications platform. As an integrity checked CDN for large files (withoutSSL). As an encrypted CDN. On webpages, as a web CDN. As a new Permanent Web where links do not die. 体验我想从第一个应用场景开始，开启我们的应用旅程。 这个场景可以把它想象成一个特别的”云盘”，这个”云盘”不依赖任何云存储商，不依赖任何平台账号，不用担心云盘提供商的内容审核，不用担心个人隐私的泄密，不用担心内容丢失或被篡改。这些特性希望通过后面的介绍，大家能够自己体会到。可以先试想下，平常我们使用云盘的几个基本需求： 上传文件 下载文件 分享文件 下面我们看IPFS如何作为一个“云盘”，来满足这些基本需求的。参考官方的get-start. 下载Demo首先下载官方提供了IPFS的Demo，比较完整的版本是Go实现的，目前最新版本是0.4.15,包含多个平台的版本，以windows 64bit系统为例，下载go-ipfs_v0.4.15_windows-amd64\\go-ipfs,由于网络限制，可能有些同学无法下载，我这边上传了一个到IPFS网络上，有需要的同学可以直接下载。 这个demo中提供了Node/Cli/Http api/Http Gateway/Library/webUi功能，本文中暂使用CLI的来体验IPFS的基本功能，为了方便在cmd直接执行IPFS命令，可以将Go-ipfs加入环境变量path中。 初始化1&gt; ipfs init 执行初始化之后，user路径下会多了一个.ipfs的文件夹，其中有一个config文件，记录的是IPFS的配置，配置内容后续的讲述中会慢慢涉及，此刻我们先了解的是IPFS节点的身份标识Identity，其中peerid，是本机IPFS的地址，下文中IPNS的使用中会涉及到peerid。当然，peerid可以通过命令行直接查看: 1&gt; ipfs id 启动Deamon执行1&gt; ipfs daemon 开启deamon之后，会启动demo中包含的IPFS服务，至此，本机就可以作为一个”个人云盘”来使用了。 上传文件12&gt; ipfs add &lt;filePath&gt; //添加文件&gt; ipfs add -r &lt;dirPath&gt; //添加文件 文件添加时，大文件会按照256KB的大小去分块，分块内容存储在.ipfs repo下的blocks文件夹下，每一个块都对应一个hash。文件添加完成之后，会返回一个文件hash，文件夹是递归添加的，会将每一个文件的hash返回，最后一个返回文件夹hash。由于IPFS中，文件都是基于内容寻址的，用户不需要关心这些文件放在哪，这些hash就是用来查找和得到文件的索引。 下载文件想要拿到一个IPFS上的文件，只需要知道文件的hash即可。下载命令：1&gt; ipfs get &lt;hash&gt; -o &lt;output_path&gt; 或者查看命令：1&gt; ipfs cat &lt;hash&gt; IPFS 的所有文件都是在本地的，Pin add可以将远端节点的文件长期保留在本地，不被垃圾回收。通过 add 添加的文件默认就是pin过的。 pin还有一个作用，pin add之后，这个节点就可以同add这个文件的节点一样，作为整个文件的服务节点。其他节点在get或pin add的时候理论上可以从这2个节点的任何一个节点拿去这个文件的块。当有很多个节点都pin add这个文件时，就会增加这个文件的获取速度，也降低了文件被删除的可能。 12&gt; ipfs pin add &lt;hash&gt;&gt; ipfs pin ls //查看哪些文件在本地是持久化的。 分享文件现实中，用户习惯获取内容的方式都通过http的方式，让用户去敲get命令去或取文件恐怕只有极客们会尝试吧。回想一下，云盘分享文件的做法，生成一个http url，把链接分享给需要的人。 IPFS demo也提供了一个http gateway，官方（公网）用的是 http://ipfs.io ,所以分享的链接可以是: http://ipfs.io/ipfs/&lt;file hash&gt; 由于某些已知原因，ipfs.io这个网关在国内是没法正常使用的，因此有条件的可以在自己的服务器上部署一个IPFS gateway（Ipfs 私网），这样，分享的链接可以是 http://&lt;gateway_host&gt;/ipfs/&lt;file hash&gt; IPNS到现在，我们分享文件还是不断地发送一个个hash组成的url，每分享一个文件就会重新生成一个url，那么可以有一固定的”网址”给我们来看你的分享呢？当然可以。这就需要借助IPNS。具体做法是1&gt; ipfs name publish &lt;file_hash&gt; 这条命令相当于把文件的hash和IPFS的节点绑定，这样就可以通过一个不变的地址来访问publish的文件 http://&lt;gateway&gt;/ipns/&lt;peerid&gt; peerid即之前介绍的本节点的唯一标识。这样做的有一个很大的缺陷，就是每次这个链接指向的都是最后一条publish的内容。但是有解决方法，大家可以查看本博客的关于页，我的IPFS主页。实现方式其实很简单，就是将将分享文件url的列表publish到ipns上。后续可能会再写一篇博文介绍做法。","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"IPFS","slug":"IPFS","permalink":"https://kekbin.com/tags/IPFS/"}]},{"title":"博客之旅-穿外衣","slug":"blog-journey-2","date":"2018-06-01T02:37:44.000Z","updated":"2019-07-19T05:52:29.532Z","comments":true,"path":"2018/06/01/blog-journey-2/","link":"","permalink":"https://kekbin.com/2018/06/01/blog-journey-2/","excerpt":"","text":"上一篇博客之旅-搭架子中已经将基本的博客搭起来了，默认是这样的 我们希望它会和默认的有一些不同。这个时候就要利用theme来设置了。还记得上一篇中hexo的目录结构么 themes目录下有本机所有的theme，默认只有landscape一种，可以在这个地址找到你喜欢的模板，比如这个博客挑选的Hueman主题,在它的文档可以查看其用法。这里简单说明。 安装模板 下载模板，直接用git clone，放到themes目录下 1$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 修改博客的_config.yml 注意是blog目录下的_config.xml 1theme: hueman 如果需要用insight search功能的话，使用npm下载 1npm install -S hexo-generator-json-content 修改模板 Menu 1234Home: /# Delete this row if you don&apos;t want categories in your header nav barCategories:About: /about/index.html 如果不想把分类放到menu中，可以把Categories这一栏删掉关于页面，网页链接到/about/index.html需要在blog目录的source文件夹下建立about文件夹，然后写index.md。不知道这样的页面的md文档该如何写，可以参考了hueman仓库的site分支的source。 也可以自定义menu，比如加入LiKe： /like/index.html,同about一样的做法。唯一需要多出的一步是，在languages的zh-cn.xml中加入Like的中文 customize 可以定义侧边栏的位置、主题颜色、高亮模式、logo样式、是否显示item的缩略图、social links的链接等 widgets 定义侧边栏项目 - catalog - recent_posts - category - archive - tag - tagcloud - links search 支持insight、swiftype、baidu三种搜索引擎，选择自己所需要的配置为true即可 comment 评论模块 share 分享按钮，选项包括default、AddToAny、JiaThis、bdshare，具体效果可以参考文档 模板的配置，基本上就是这些，github上的它的文档讲的很清楚，另外还有一些如插件之类的配置，可以自己摸索！ 最后的最后—性能由于是托管在GitHub上的，带宽和访问量必然收到一定的限制，毕竟是免费的东西，方可少的话，还是够用的。另外也可以托管到放到码云OsChina上，可以将github上的博客托管迁移到Oschina。 网页部署好之后发现，会有一些请求无法完成，有一些浏览器，特别是手机上，一直在进度条上。查看了下开发者选项，发现有一些js的请求，是用的http方式请求的。由于github上托管时勾选了https选项。在github上提了一个issue，将持续关注它2018/6/4: PPoffice已经将我提交的issue标记为bug，已经修复 另外，count.js的的请求会有pending，由于没有配置disques评论相关的内容，所以可以现在_config.yml中关闭默认的comment配置","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://kekbin.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://kekbin.com/tags/hexo/"}]},{"title":"博客之旅--搭架子","slug":"blog_journey-1","date":"2018-05-31T10:32:23.000Z","updated":"2019-07-19T05:50:47.546Z","comments":true,"path":"2018/05/31/blog_journey-1/","link":"","permalink":"https://kekbin.com/2018/05/31/blog_journey-1/","excerpt":"","text":"心血来潮最近做了一个利用去中心化存储技术IPFS实现dweb的项目，将个人内容发布到IPFS上，生成个人主页展示。于是就有了一个用IPFS托管博客网页的想法，具体做法应该是： 12$ ipfs add &lt;index.html&gt; #将博客静态网页add到ipfs上，得到hash$ ipfs name publish &lt;hash&gt; #将博客的hash和IPFS namespace绑定 这样操作就可以直接通过IPNS来查看网页，链接可能是这样的： 1http://&lt;IPFS http Gateway&gt;/ipns/&lt;peerid&gt; 可是这样的主页地址会是一个很长的链接，譬如： 1http://&lt;xxx.xx.xxx.xxx:8080&gt;/ipns/QmSrYNxg3RdhdyyGYNBSqdH1wdRGqf1ENhXGQaHL8rACLb/ 这样的一串链接很难映射到一个域名上。因此，退而求其次，利用github page托管静态网页，把图片/音乐/视频等大体积资源文件放在IPFS上，免受了github page空间的限制 把搭个人博客的坑踩一遍网络上有很多关于用github page 托管网页，用 Hexo生成博客静态网页做法的文章。花了一些时间，把所有的步骤走了一遍，搭起来这个架子，期间也遇到了一些问题，简单记录： 本地搭建博客生成工具Hexo 安装node.js 不同的系统安装方式不太一样，windows上直接下载并安装，安装的时候默认把环境变量配置完成，用如下命令，验证是否把nodejs和npm（下载工具）安装成功，如果没有及时生效，可以重启一次电脑 12$ node -v$ npm -v 额外的，安装完之后可以建立2个文件夹，并配置下载资源存储路径，这样安装Hexo等module的时候，就可以方便地找到它。配置如下: 12$ npm config set prefix &quot;installpath\\nodejs\\node_global&quot;$ npm config set cache &quot;installpath\\nodejs\\node_cache&quot; 安装git 1程序员必备版本控制工具，非安装用户安装方式自行百度 安装Hexo 用npm直接下载到node_global目录下： 12$ npm install -g hexo-cli或简写 $ npm i -g hexo 建立本地博客系统 在本地路径下建立一个文件夹用于存放博客系统的文件路径12$ cd &lt;blog path&gt;$ hexo init #初始化hexo 其中： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 在本地生成了一个默认的博客网页1$ hexo new &quot;xxxx&quot; # 在_post目录下新建一个markdown文档，便于写新的博客 1$ hexo generate(简写hexo g) #生成静态网页 开启本地server，默认可以通过localhost:4000来查看博客网页 1$ hexo server 3.简单修改网页配置12345678# Sitetitle: 可可冰的奇幻之旅subtitle:description:keywords:author: KekBinlanguage: zh-CNtimezone: 将网页托管到GitHub上 在github上建立一个工程，如 https://github.com/vandep/vandep.github.io 用编辑器打开你的blog项目，修改_config.yml文件deploy配置 1234deploy: type: git repo: https://github.com/vandep/vandep.github.io.git branch: master 此处有坑： type/repo/branch的冒号后面都必须有一个空格，否则发布的时候会报错 type/repo/branch和deploy的缩进必须是一个TAB 安装deploy工具 1$ npm install hexo-deployer-git --save 发布网页 1$ hexo deploy 绑定域名（非必需） 如果你有一个域名 1如果没有域名可以直接通过github.io，如https://vandep.github.io来访问 在github的blog工程下绑定域名 12在工程中，如https://github.com/vandep/vandep.github.io的settings下github pages一栏中cutom domain添加你的域名，save 在你的域名服务器上添加一条CNAME 12345678910一条主机名为www， value为vandep.github.io，这样允许带www来访问自己的域名一条主机名为@，value为vandep.github.io，允许不带www访问自己的域名可是godaddy中不允许CNAME的主机名使用@，所以只能添加一条A记录：ping vandep.github.io，得到一个ip，添加A记录主机名为@， 指为IP这样的坏处就是是固定主机的，可能ip会变，也没法CDN加速 在CNAME文件中添加域名 如 kekbin.com 在CNAME文件中添加域名放在本机 blog 根目录下的source文件夹中否则每次重新deploy的时候，都会重新生成CNAME上传，这样需要重新在github上添加域名。 6.每次修改网页的内容，重新发布 一键生成并发布1$ hexo g -d 或者先在本地生成，启动本地server，在localhost:4000验证之后再发布123$ hexo g#验证之后$ hexo d 至此，简单的架子搭好，架子搭好之后，还需要漂亮的外衣，这就需要借助theme了，下篇介绍。","categories":[{"name":"技术","slug":"技术","permalink":"https://kekbin.com/categories/技术/"}],"tags":[{"name":"IPFS","slug":"IPFS","permalink":"https://kekbin.com/tags/IPFS/"},{"name":"blog","slug":"blog","permalink":"https://kekbin.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://kekbin.com/tags/hexo/"}]}]}